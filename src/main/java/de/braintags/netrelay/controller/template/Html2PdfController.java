package de.braintags.netrelay.controller.template;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Properties;

import org.xhtmlrenderer.pdf.ITextRenderer;

import com.itextpdf.text.DocumentException;

import de.braintags.io.vertx.util.exception.NoSuchFileException;
import de.braintags.io.vertx.util.file.FileSystemUtil;
import de.braintags.netrelay.controller.impl.AbstractController;
import de.braintags.netrelay.controller.impl.ThymeleafTemplateController;
import io.vertx.core.AsyncResult;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.buffer.Buffer;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.templ.ThymeleafTemplateEngine;

/**
 * Html2PdfController creates a pdf document from an html source, which was generated by a template by Thymeleaf. The
 * template, which shall be used can be defined on two different ways:
 * <UL>
 * <LI>by property {@value #TEMPLATE_NAME_PROP}<br/>
 * if this property is defined, then for each request this template is taken
 * <LI>by the requested path<br/>
 * if the above property is not set, then the controller will use the current request path as template path. He will
 * exchange the file extension against ".html" to find a corresponding template. Thus a request to "/testpath/test.pdf"
 * will lead to a template with the path /testpath/test.html"
 * </UL>
 * <br>
 * <br>
 * <br/>
 * Config-Parameter:<br/>
 * possible parameters, which are read from the configuration
 * <UL>
 * <LI>{@value #TEMPLATE_NAME_PROP}
 * <LI>{@value #FONT_PATH_PROP}
 * <LI/>all parameters like defined in {@link ThymeleafTemplateController}
 * </UL>
 * <br>
 * 
 * Request-Parameter:<br/>
 * none
 * <br/>
 * 
 * Result-Parameter:<br/>
 * none
 * <br/>
 * 
 * Copyright: Copyright (c) 09.03.2016 <br>
 * Company: Braintags GmbH <br>
 * 
 * @author mremme
 * 
 */

public class Html2PdfController extends AbstractController {
  private static final io.vertx.core.logging.Logger LOGGER = io.vertx.core.logging.LoggerFactory
      .getLogger(Html2PdfController.class);

  /**
   * If the content shall be generated by one specific template, this is defined with this property. If this property is
   * undefined, the template will be used by using the path of the current request.
   */
  public static final String TEMPLATE_NAME_PROP = "template";

  /**
   * The property defines the path to a directory, where font definitions are stored as ttf or otf files. All found
   * definitions are added to the resulting pdf
   */
  public static final String FONT_PATH_PROP = "fonts";

  private String template;
  private ThymeleafTemplateEngine templateEngine;
  private String templateDirectory;
  private String fontsDir;

  /**
   * 
   */
  public Html2PdfController() {
  }

  /*
   * (non-Javadoc)
   * 
   * @see io.vertx.core.Handler#handle(java.lang.Object)
   */
  @Override
  public void handle(RoutingContext context) {
    createTemplateContent(context, tc -> {
      if (succeeded(context, tc)) {
        convert(tc.result(), cr -> {
          if (succeeded(context, cr)) {
            Buffer buff = cr.result();
            context.response().headers().set("content-length", String.valueOf(buff.length()));
            context.response().end(buff);
          }
        });
      }
    });
  }

  private void convert(Buffer htmlText, Handler<AsyncResult<Buffer>> handler) {
    getVertx().executeBlocking(future -> {
      createPdf(htmlText, future);
    } , result -> {
      if (result.failed()) {
        handler.handle(Future.failedFuture(result.cause()));
      } else {
        handler.handle(Future.succeededFuture((Buffer) result.result()));
      }
    });
  }

  private void createPdf(Buffer htmlText, Future future) {
    try {
      ByteArrayOutputStream os = new ByteArrayOutputStream();
      ITextRenderer renderer = new ITextRenderer();
      readFonts(renderer);
      renderer.setDocumentFromString(htmlText.toString());
      renderer.layout();
      renderer.createPDF(os);
      byte[] pdfAsBytes = os.toByteArray();
      os.close();
      future.complete(Buffer.buffer(pdfAsBytes));
    } catch (IOException | DocumentException | NoSuchFileException e) {
      future.fail(e);
    }

  }

  private void readFonts(ITextRenderer renderer) throws NoSuchFileException, DocumentException, IOException {
    if (fontsDir != null) {
      List<String> children = FileSystemUtil.getChildren(getVertx(), fontsDir,
          child -> child.toLowerCase().endsWith(".otf") || child.toLowerCase().endsWith(".ttf"));
      for (String child : children) {
        renderer.getFontResolver().addFont(child, true);
      }
    }
  }

  private boolean succeeded(RoutingContext context, AsyncResult<?> res) {
    if (res.failed()) {
      context.fail(res.cause());
      return false;
    }
    return true;
  }

  private void createTemplateContent(RoutingContext context, Handler<AsyncResult<Buffer>> handler) {
    String file = getTemplatePath(context);
    templateEngine.render(context, file, handler);
  }

  private String getTemplatePath(RoutingContext context) {
    String t = template == null || template.hashCode() == 0 ? context.request().path() : template;
    int index = t.lastIndexOf('.');
    if (index > 0) {
      t = t.substring(0, index) + ".html";
    }
    return templateDirectory + "/" + t;
  }

  /*
   * (non-Javadoc)
   * 
   * @see de.braintags.netrelay.controller.impl.AbstractController#initProperties(java.util.Properties)
   */
  @Override
  public void initProperties(Properties props) {
    template = readProperty(props, TEMPLATE_NAME_PROP, null, false);
    fontsDir = readProperty(props, FONT_PATH_PROP, null, false);
    templateEngine = ThymeleafTemplateController.createTemplateEngine(props);
    templateDirectory = ThymeleafTemplateController.getTemplateDirectory(props);
  }

}
